;; AudioTon Reward Distributor Contract
;; Distributes platform rewards based on user activity and engagement

#include "imports/stdlib.fc";

const int ERROR_NOT_OWNER = 100;
const int ERROR_INSUFFICIENT_REWARDS = 101;
const int ERROR_INVALID_PROOF = 102;
const int ERROR_CLAIM_TOO_EARLY = 103;

;; Storage format:
;; owner:MsgAddress reward_pool:Coins distribution_period:uint32 min_claim_amount:Coins last_distribution:uint32

(slice, int, int, int, int) load_data() inline {
  var ds = get_data().begin_parse();
  return (
    ds~load_msg_addr(),  ;; owner
    ds~load_coins(),     ;; reward_pool
    ds~load_uint(32),    ;; distribution_period
    ds~load_coins(),     ;; min_claim_amount
    ds~load_uint(32)     ;; last_distribution
  );
}

() save_data(slice owner, int reward_pool, int distribution_period, int min_claim_amount, int last_distribution) impure inline {
  set_data(begin_cell()
    .store_slice(owner)
    .store_coins(reward_pool)
    .store_uint(distribution_period, 32)
    .store_coins(min_claim_amount)
    .store_uint(last_distribution, 32)
    .end_cell());
}

() send_money(slice to_addr, int amount, int mode) impure inline {
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(to_addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .end_cell();
  send_raw_message(msg, mode);
}

int verify_activity_proof(slice user_addr, cell proof, int claimed_amount) inline {
  ;; Simplified proof verification
  ;; In production, this would verify merkle proofs or other cryptographic evidence
  slice proof_data = proof.begin_parse();
  int proof_timestamp = proof_data~load_uint(32);
  int proof_activity_score = proof_data~load_uint(32);
  
  ;; Basic validation
  return (proof_timestamp > now() - 86400) & (proof_activity_score * 1000000 >= claimed_amount);
}

() process_add_rewards(int amount) impure {
  (slice owner, int reward_pool, int distribution_period, int min_claim_amount, int last_distribution) = load_data();
  save_data(owner, reward_pool + amount, distribution_period, min_claim_amount, last_distribution);
  
  ;; Emit rewards added event
  emit_log_simple(0x72657741, begin_cell() ;; "rewA"
    .store_coins(amount)
    .store_coins(reward_pool + amount)
    .store_uint(now(), 32)
    .end_cell());
}

() process_claim_rewards(slice claimant_addr, int amount, cell activity_proof) impure {
  (slice owner, int reward_pool, int distribution_period, int min_claim_amount, int last_distribution) = load_data();
  
  throw_unless(ERROR_INSUFFICIENT_REWARDS, amount <= reward_pool);
  throw_unless(ERROR_INSUFFICIENT_REWARDS, amount >= min_claim_amount);
  throw_unless(ERROR_INVALID_PROOF, verify_activity_proof(claimant_addr, activity_proof, amount));
  
  ;; Send rewards to claimant
  send_money(claimant_addr, amount - 5000000, 1); ;; Reserve gas
  
  ;; Update reward pool
  save_data(owner, reward_pool - amount, distribution_period, min_claim_amount, last_distribution);
  
  ;; Emit claim event
  emit_log_simple(0x72657743, begin_cell() ;; "rewC"
    .store_slice(claimant_addr)
    .store_coins(amount)
    .store_uint(now(), 32)
    .end_cell());
}

() process_distribute_rewards(cell recipients_dict, int total_recipients) impure {
  (slice owner, int reward_pool, int distribution_period, int min_claim_amount, int last_distribution) = load_data();
  
  ;; Check if enough time has passed since last distribution
  throw_unless(ERROR_CLAIM_TOO_EARLY, now() >= last_distribution + distribution_period);
  
  int total_distributed = 0;
  int i = 0;
  
  while (i < total_recipients) {
    (slice recipient_data, int success) = recipients_dict.udict_get?(16, i);
    if (success) {
      slice recipient_addr = recipient_data~load_msg_addr();
      int reward_amount = recipient_data~load_coins();
      slice reward_type = recipient_data~load_ref().begin_parse().preload_ref();
      
      if (reward_amount <= reward_pool - total_distributed) {
        send_money(recipient_addr, reward_amount - 2000000, 1); ;; Reserve gas
        total_distributed += reward_amount;
        
        ;; Emit individual distribution event
        emit_log_simple(0x72657744, begin_cell() ;; "rewD"
          .store_slice(recipient_addr)
          .store_coins(reward_amount)
          .store_slice(reward_type)
          .end_cell());
      }
    }
    i += 1;
  }
  
  ;; Update state
  save_data(owner, reward_pool - total_distributed, distribution_period, min_claim_amount, now());
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }
  
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  
  if (flags & 1) { ;; ignore bounced messages
    return ();
  }
  
  slice sender_addr = cs~load_msg_addr();
  
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);
  
  if (op == 0x01) { ;; add rewards
    int reward_amount = in_msg_body~load_coins();
    process_add_rewards(reward_amount);
    return ();
  }
  
  if (op == 0x02) { ;; claim rewards
    slice claimant_addr = in_msg_body~load_msg_addr();
    int amount = in_msg_body~load_coins();
    cell activity_proof = in_msg_body~load_ref();
    
    process_claim_rewards(claimant_addr, amount, activity_proof);
    return ();
  }
  
  if (op == 0x03) { ;; distribute rewards
    (slice owner, _, _, _, _) = load_data();
    throw_unless(ERROR_NOT_OWNER, equal_slices(sender_addr, owner));
    
    cell recipients_dict = in_msg_body~load_dict();
    int total_recipients = in_msg_body~load_uint(16);
    
    process_distribute_rewards(recipients_dict, total_recipients);
    return ();
  }
  
  if (op == 0x04) { ;; update config (owner only)
    (slice owner, int reward_pool, _, int min_claim_amount, int last_distribution) = load_data();
    throw_unless(ERROR_NOT_OWNER, equal_slices(sender_addr, owner));
    
    int new_distribution_period = in_msg_body~load_uint(32);
    int new_min_claim_amount = in_msg_body~load_coins();
    
    save_data(owner, reward_pool, new_distribution_period, new_min_claim_amount, last_distribution);
    return ();
  }
  
  throw(0xffff); ;; unknown operation
}

;; Get methods
int get_reward_pool_balance() method_id {
  (_, int reward_pool, _, _, _) = load_data();
  return reward_pool;
}

(int, int, int, int) get_distribution_stats() method_id {
  (_, int reward_pool, int distribution_period, int min_claim_amount, int last_distribution) = load_data();
  return (reward_pool, distribution_period, min_claim_amount, last_distribution);
}

slice get_owner() method_id {
  (slice owner, _, _, _, _) = load_data();
  return owner;
}

int get_balance() method_id {
  return get_balance().pair_first();
}